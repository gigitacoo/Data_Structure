/**
 * 
 * 树的深度（高度）——一棵树中所有结点层次数的最大值。
 * 符号⌊ x ⌋表示不大于x的最大整数。
 * 
 * 二叉树：
 * 性质一：在二叉树的第i(i>=1)层上至多有2^(i-1)个结点。
 * 性质二：深度为k(k>=1)的二叉树至多有(2^k)-1个结点。
 * 性质三：对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0＝n2＋1。即：叶结点数n0=度为2的结点数n2+1
 * 性质四：具有n个结点的完全二叉树的深度为 ⌊log2n⌋+1
 * 性质五：算双亲和左右孩子节点编号
 *  （1）如果i＝1，则结点i无双亲，是二叉树的根；如果i>1，则i的双亲Parent(A)是结点⌊i/2⌋; 
 *  （2）如果2*i≤n，则其左孩子是结点2*i,否则，结点i无左孩子且为叶子结点；
 *  （3）如果2*i＋1≤n，则其右孩子是结点2*i＋1，否则，结点i无右孩子。
 * 
 * 三个结点可构成5种不同形态的二叉树。 卡特兰数  （2n)!/((n+1)!n!) ，
 *  根      根    根             根    根
 * 左 右，     左    右        左          右
 *         左          右        右    左
 * 
 * 满二叉树——深度为k(k>=1)且有2^k-1个结点的二叉树。
 * 完全二叉树——深度为K的二叉树中，K-1层结点数是满的(2^(k-2) )，K层结点是左连续的(即结点编号是连续的)。
 * 
 * 满二叉树的叶子结点个数是2^(k-1)，即2的(k-1)次个。如3层有4个叶子结点。
 * 高度为k的完全二叉树，k-1层的结点个数是2^(k-2)个，第K层至少有一个结点，所以至少应该有2^(k-2)个。 
 * 
 * 具有n个结点的完全二叉树的深度是|log2n| + 1.  log2n向下去整
 * 结点数量=n2+n1+n0.   其中n2 = n0-1
*/

//二叉链表
//在含n个结点的二叉链表中有2n个指针域，其中n-1个用来指向结点的左右孩子，其余n+1个空链域.
#include "SeqList.h"

typedef struct btNode
{
    int id;
    struct btNode *lchild, *rchild;
    //三叉表示法
    //struct btNode *parent;
} * BTreeList;
//双亲表示法
typedef struct
{
    DataType data;
    int parent;
} PNode;
PNode slist[10];

/*
孩子链表表示法
类似数组 + 链表的表示法
找孩子方便，但求结点的双亲困难，因此可在顺序表中再增加一个域
0 A -> [1, ->] [2, ^]
1 B -> [3, ->] [4, ^]
2 C -> [5, ->] [6, ^]
3 D ^
4 E -> [7, ->] [8, ->] [9, ^]
5 F
*/
typedef struct bnode
{
    int child; //孩子结点坐标
    struct bnode *next;
} node, *childlink;
typedef struct
{
    DataType data;
    int parent; //双亲结点坐标
    childlink hp;
} headnode;
headnode link[20];

/*
孩子兄弟表示法
A
|
B -> C----|
|         |
D -> E -> F
*/
typedef struct tnode
{
    DataType data;
    struct tnode *son, *brother;
} * Tree;

/*
哈夫曼树的转换过程见图：HalfManTree.png
初始森林共有n棵二叉树，每棵树中都仅有一个孤立的结点，要进行n-1次合并才能得到哈夫曼树，每次合并产生一个新结点。
最终有2n-1个结点。
*/
//采用顺序存储，设置大小为2n-1的数组，每个数组元素由4个域组成：存储权值、双亲指针、左孩子指针和右孩子指针。类型定义如下：
const int hfn = 10;
typedef struct
{
    float w;                    //w为结点的权值
    int parent, lchild, rchild; //父结点和左、右孩子所在数组的下标
} seqNode;
typedef seqNode hftree[2 * hfn - 1];

/*
哈夫曼编码： 可利用哈夫曼树构造用于通信的二进制编码称为哈夫曼编码。
树中从根到每个叶子都有一条路径，对路径上的各分支约定指向左子树根的分支表示“0”码。
指向右子树的分支表示“1”码，取每条路径上的“0”或“1”的序列作为和各个叶子对应的字符的编码，这就是哈夫曼编码


每个字符在电文中出现的次数为wi，其编码长为mi，电文有n种字符.
          n
则电文总长=∑(wi*mi)
        i=1
◆ 什么是哈夫曼编码？如何设计？
◆ 求哈夫曼编码的算法。。
例子：如果需传送的电文为 ‘ABCACCDAEAE’，即：A, B, C, D, E 的频率（即权值）分别为0.36, 0.1, 0.27, 0.1, 0.18，试构造哈夫曼编码。
编码总长：A出现次数4 * 0.36 + B次数1*0.1 + 3 * 0.27 + 1*0.1 + 2*0.18
最小值为0.1，则先选出B，D。相加后组成：
     0.2
    B   D
   0.1 0.1
得到新森林0.18，0.2，0.27，0.36，重复组合0.18，0.2得到
    0.38
  E      0.2  
0.18    B    D
       0.1  0.1
得到新森林0.27，0.36，0.38,再组合：
             1.01
    0.38                0.63
  E      0.2        C         A
0.18    B    D     0.27     0.36
       0.1  0.1

‘ABCACCDAEAE’，根据左树分支是0，右树是1得到：110101011101001111001100

译码:
从哈夫曼树根开始，对待译码电文逐位取码。若编码是“0”，则向左走；若编码是“1”，则向右走，一旦到达叶子结点，则译出一个字符；再重新从根出发，直到电文结束。
*/